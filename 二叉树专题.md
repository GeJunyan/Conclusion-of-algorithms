# 二叉树专题

## 1 翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        if(root == nullptr) return nullptr;
        
        //交换
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;

        invertTree(root->left);
        invertTree(root->right);

        return root;
    }
};
```

关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。

## 2 填充二叉树节点的右侧指针

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:

    void connectTwoNode(Node *node1, Node *node2)
    {
         if (node1 == nullptr || node2 == nullptr)  return;

         node1->next = node2;
         connectTwoNode(node1->left, node1->right);
         connectTwoNode(node2->left, node2->right);
         connectTwoNode(node1->right, node2->left);
    
    }

    Node* connect(Node* root) {

        if (root == nullptr || root->left == nullptr) 
        {
            return root;
        }

        connectTwoNode(root->left, root->right);
        return root;

        
    }
};
```

如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」

# 3 构造最大二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    TreeNode* build(vector<int>& nums, int lo, int hi)
    {
        if(lo > hi) return nullptr;
        int index = -1;
        int maxVal = INT_MIN;
        //尤其注意for循环的范围
        for (int i = lo; i <= hi; i++) 
        {
            if (maxVal < nums[i]) 
            {
                index = i;
                maxVal = nums[i];
            }
        }
        TreeNode* root = new TreeNode(maxVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }



    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums,0,nums.size()-1);
    }
};
```

对于每个根节点，只需要找到当前`nums`中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可。

## 4 通过前序和中序遍历结果构造二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& inorder, int inStart, int inEnd)
    {
        if (preStart > preEnd) 
            return nullptr;

        int rootVal = preorder[preStart];

        //在中序中找到根的位置
        int index = -1;
        for(int i = inStart; i <= inEnd; i++)
        {
            if(inorder[i] == rootVal)
            {
                index = i;
                break;
            }
        }

        TreeNode* root = new TreeNode(rootVal);

        int left_size = index - inStart; 

        root->left = build(preorder, preStart+1,preStart+left_size,
                            inorder,inStart,index-1);

        root->right = build(preorder, preStart+left_size+1,preEnd,
                            inorder,index+1,inEnd);
        
        return root;
    }



    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return build(preorder,0,preorder.size()-1,
                     inorder,0,inorder.size()-1);
    }
};
```

## 5 寻找重复的子树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> res;
    map<string, int> my_map;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root)
    {
        traverse(root);
        return res;
    }

    string traverse(TreeNode* root)
    {
        if (root==nullptr) return "#";
        string left = traverse(root->left);
        string right = traverse(root->right);

        string subTree = left + ',' + right + ',' + to_string(root->val);

        int freq = my_map[subTree];
        if(freq == 1) res.push_back(root);
        my_map[subTree]++;
        return subTree;
    }
};
```

