# 二叉树专题

## 1 翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        if(root == nullptr) return nullptr;
        
        //交换
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;

        invertTree(root->left);
        invertTree(root->right);

        return root;
    }
};
```

关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。

## 2 填充二叉树节点的右侧指针

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:

    void connectTwoNode(Node *node1, Node *node2)
    {
         if (node1 == nullptr || node2 == nullptr)  return;

         node1->next = node2;
         connectTwoNode(node1->left, node1->right);
         connectTwoNode(node2->left, node2->right);
         connectTwoNode(node1->right, node2->left);
    
    }

    Node* connect(Node* root) {

        if (root == nullptr || root->left == nullptr) 
        {
            return root;
        }

        connectTwoNode(root->left, root->right);
        return root;

        
    }
};
```

如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」