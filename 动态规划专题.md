# 动态规划专题

## 746.使用最小花费爬楼梯

1. 确定dp数组以及下标的含义

使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。

**dp[i]的定义：第i个台阶所花费的最少体力为dp[i]**。

**对于dp数组的定义，大家一定要清晰！**

2. 确定递推公式

**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

那么究竟是选dp[i-1]还是dp[i-2]呢？

一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int>dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];

        
        for(int i = 2; i < dp.size(); i++)
        {
            dp[i] = min(dp[i-1],dp[i-2]) + cost[i];
        }

        return  min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```

## 62.不同路径：

1. 确定dp数组（dp table）以及下标的含义

dp ij：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

2. 确定递推公式

想要求dp ij，只能有两个方向来推导出来，即dp i-1 j和 dp i j-1。

3. dp数组的初始化

如何初始化呢，首先dp i 0一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp 0 j 也同理。

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {

        //注意二维数组初始化的写法
        vector<vector<int>> dp(m, vector<int>(n, 0));

        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int j = 0; j < n; j++) dp[0][j] = 1;

        //开始遍历
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

